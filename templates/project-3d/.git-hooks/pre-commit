#!/usr/bin/env bash
# Pre-commit hook to check for large files and binary assets without DVC tracking
# Prompts user to add files to DVC before committing based on:
# - File size (>10MB)
# - File types specified in .gitignore (images, audio, models, video, etc.)

set -e

# Configuration
SIZE_THRESHOLD=${DVC_HOOK_SIZE_THRESHOLD:-10485760}  # 10MB default, configurable via env var

# File types that should be tracked with DVC
DVC_FILE_TYPES=(
    # Images/Textures
    "png" "jpg" "jpeg" "tga" "exr" "hdr" "tiff" "bmp" "psd"
    # Audio
    "wav" "mp3" "ogg" "aiff" "flac"
    # 3D Models
    "fbx" "obj" "blend" "max" "ma" "mb"
    # Video
    "mp4" "mov" "avi" "mkv" "webm"
    # Other large binaries
    "zip" "rar" "7z" "tar.gz"
)

# Check if file should be tracked with DVC
should_track_with_dvc() {
    local file="$1"
    local file_size="$2"
    
    # Check size threshold
    if [ "$file_size" -gt "$SIZE_THRESHOLD" ]; then
        return 0
    fi
    
    # Check file extension
    local ext="${file##*.}"
    ext="${ext,,}"  # Convert to lowercase
    
    # Handle special case for .tar.gz
    [[ "$file" == *.tar.gz ]] && ext="tar.gz"
    
    # Check against DVC file types
    for dvc_ext in "${DVC_FILE_TYPES[@]}"; do
        [[ "$ext" == "$dvc_ext" ]] && return 0
    done
    
    return 1
}

# Get file size with error handling
get_file_size() {
    stat -c%s "$1" 2>/dev/null || echo 0
}

# Format file size for display
format_size() {
    local size="$1"
    if [ "$size" -gt "$SIZE_THRESHOLD" ]; then
        echo "($(( size / 1048576 ))MB - large file)"
    else
        echo "(binary asset type)"
    fi
}

# Add files to DVC tracking
add_files_to_dvc() {
    local files=("$@")
    
    echo "📦 Adding files to DVC..."
    for file in "${files[@]}"; do
        echo "  Processing: $file"
        
        # Remove from Git staging
        git rm --cached "$file" >/dev/null 2>&1 || git reset HEAD "$file" >/dev/null 2>&1 || true
        
        # Add to DVC
        if dvc add "$file"; then
            # Stage DVC file and any gitignore changes
            git add "${file}.dvc" .gitignore "$(dirname "$file")/.gitignore" 2>/dev/null || true
        else
            echo "  ⚠️  Failed to add $file to DVC"
            return 1
        fi
    done
    
    echo "✅ Files added to DVC. Proceeding with commit."
    return 0
}

# Prompt user for DVC addition
prompt_user() {
    local files=("$@")
    
    if command -v gum >/dev/null 2>&1; then
        gum confirm "Add these files to DVC tracking?"
    else
        read -p "Add these files to DVC tracking? (y/N): " -n 1 -r
        echo
        [[ $REPLY =~ ^[Yy]$ ]]
    fi
}

# Main execution
main() {
    # Get staged files
    local staged_files
    staged_files=$(git diff --cached --name-only --diff-filter=ACM)
    
    [ -z "$staged_files" ] && exit 0
    
    local files_needing_dvc=()
    
    # Check each staged file
    while IFS= read -r file; do
        [ -f "$file" ] || continue
        
        local file_size
        file_size=$(get_file_size "$file")
        
        # Check if should be tracked with DVC and isn't already
        if should_track_with_dvc "$file" "$file_size" && [ ! -f "${file}.dvc" ]; then
            files_needing_dvc+=("$file")
        fi
    done <<< "$staged_files"
    
    # Exit if no files need DVC tracking
    [ ${#files_needing_dvc[@]} -eq 0 ] && exit 0
    
    # Display files that need DVC tracking
    echo "⚠️  Found files that should be tracked with DVC:"
    for file in "${files_needing_dvc[@]}"; do
        local file_size
        file_size=$(get_file_size "$file")
        echo "  - $file $(format_size "$file_size")"
    done
    echo
    
    # Prompt user and handle response
    if prompt_user "${files_needing_dvc[@]}"; then
        if add_files_to_dvc "${files_needing_dvc[@]}"; then
            exit 0
        else
            echo "❌ Failed to add some files to DVC. Commit blocked."
            exit 1
        fi
    else
        echo "❌ Commit blocked. Files that should be tracked with DVC found."
        echo "   Run 'dvc add <file>' for each file, then commit again."
        exit 1
    fi
}

# Run main function
main "$@"
